#!/bin/bash
# CamGuard Video Transfer Service
# Transfers recorded videos to remote server with bandwidth limiting
# Generated by Ansible for {{ inventory_hostname }}

set -euo pipefail

# Configuration
RECORDINGS_DIR="{{ camguard.storage.recordings_dir }}"
LOGS_DIR="{{ camguard.storage.logs_dir }}"
LOG_FILE="${LOGS_DIR}/camguard_transfer.log"
PID_FILE="${LOGS_DIR}/camguard_transfer.pid"

# Transfer configuration
REMOTE_SERVER="{{ camguard.transfer.remote_server }}"
REMOTE_PATH="{{ camguard.transfer.remote_path }}"
REMOTE_USER="{{ camguard.transfer.username }}"
REMOTE_PORT="{{ camguard.transfer.port }}"
SSH_KEY="{{ camguard.transfer.ssh_key_path }}"
RATE_LIMIT_MBPS="{{ camguard.transfer.rate_limit_mbps }}"
DELETE_AFTER_TRANSFER="{{ camguard.transfer.delete_after_transfer | lower }}"
RETRY_ATTEMPTS="{{ camguard.transfer.retry_attempts }}"
CONNECTION_TIMEOUT="{{ camguard.transfer.connection_timeout }}"
VERIFY_TRANSFER="{{ camguard.transfer.verify_transfer | lower }}"

# Convert Mbps to KB/s for rsync (1 Mbps = 125 KB/s)
RATE_LIMIT_KBS=$((RATE_LIMIT_MBPS * 125))

# Lock file to prevent multiple instances
LOCK_FILE="${LOGS_DIR}/camguard_transfer.lock"

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [transfer] $*" | tee -a "${LOG_FILE}"
}

# Error handling
error_exit() {
    log "ERROR: $1"
    cleanup_and_exit 1
}

# Cleanup function
cleanup_and_exit() {
    local exit_code=${1:-0}
    rm -f "${PID_FILE}" "${LOCK_FILE}"
    log "CamGuard transfer service stopped (exit code: ${exit_code})"
    exit "${exit_code}"
}

# Signal handlers
trap 'cleanup_and_exit 0' SIGTERM SIGINT SIGQUIT

# Check if transfer is enabled
if [ -z "${REMOTE_SERVER}" ] || [ -z "${REMOTE_PATH}" ] || [ -z "${REMOTE_USER}" ]; then
    error_exit "Transfer not properly configured. Missing required parameters."
fi

# Check for existing lock file
if [ -f "${LOCK_FILE}" ]; then
    if [ -f "${PID_FILE}" ] && kill -0 "$(cat "${PID_FILE}")" 2>/dev/null; then
        log "Transfer already running (PID: $(cat "${PID_FILE}")). Exiting."
        exit 0
    else
        log "Stale lock file found. Removing..."
        rm -f "${LOCK_FILE}" "${PID_FILE}"
    fi
fi

# Create lock file and store PID
touch "${LOCK_FILE}"
echo $$ > "${PID_FILE}"

# Create directories if they don't exist
mkdir -p "${RECORDINGS_DIR}" "${LOGS_DIR}"

log "Starting CamGuard video transfer service"
log "Configuration:"
log "  Remote server: ${REMOTE_USER}@${REMOTE_SERVER}:${REMOTE_PORT}"
log "  Remote path: ${REMOTE_PATH}"
log "  Rate limit: ${RATE_LIMIT_MBPS} Mbps (${RATE_LIMIT_KBS} KB/s)"
log "  Delete after transfer: ${DELETE_AFTER_TRANSFER}"
log "  Retry attempts: ${RETRY_ATTEMPTS}"
log "  SSH key: ${SSH_KEY}"

# Check if recordings directory exists and has files
if [ ! -d "${RECORDINGS_DIR}" ]; then
    log "Recordings directory does not exist: ${RECORDINGS_DIR}"
    cleanup_and_exit 0
fi

# Count total files to transfer
TOTAL_FILES=$(find "${RECORDINGS_DIR}" -name "rec-*.{{ camguard.recording.format }}" -type f 2>/dev/null | wc -l | tr -d ' ')
if [ "${TOTAL_FILES}" -eq 0 ]; then
    log "No video files found to transfer"
    cleanup_and_exit 0
fi

log "Found ${TOTAL_FILES} video files to transfer"

# Check SSH connectivity
log "Testing SSH connectivity to ${REMOTE_USER}@${REMOTE_SERVER}:${REMOTE_PORT}..."
if ! ssh -i "${SSH_KEY}" \
         -p "${REMOTE_PORT}" \
         -o ConnectTimeout="${CONNECTION_TIMEOUT}" \
         -o StrictHostKeyChecking=no \
         -o UserKnownHostsFile=/dev/null \
         -o BatchMode=yes \
         "${REMOTE_USER}@${REMOTE_SERVER}" \
         "mkdir -p '${REMOTE_PATH}'" 2>>"${LOG_FILE}"; then
    error_exit "Failed to connect to remote server or create directory"
fi

log "SSH connectivity confirmed. Remote directory ready."

# Function to get file size
get_file_size() {
    local file="$1"
    if [ -f "${file}" ]; then
        stat -f%z "${file}" 2>/dev/null || echo 0
    else
        echo 0
    fi
}

# Function to verify transfer integrity
verify_file_transfer() {
    local local_file="$1"
    local remote_file="${REMOTE_PATH}/$(basename "${local_file}")"
    
    if [ "${VERIFY_TRANSFER}" != "true" ]; then
        return 0
    fi
    
    local local_size
    local_size=$(get_file_size "${local_file}")
    
    local remote_size
    remote_size=$(ssh -i "${SSH_KEY}" \
                      -p "${REMOTE_PORT}" \
                      -o ConnectTimeout="${CONNECTION_TIMEOUT}" \
                      -o StrictHostKeyChecking=no \
                      -o UserKnownHostsFile=/dev/null \
                      -o BatchMode=yes \
                      "${REMOTE_USER}@${REMOTE_SERVER}" \
                      "stat -f%z '${remote_file}' 2>/dev/null || echo 0")
    
    if [ "${local_size}" -eq "${remote_size}" ] && [ "${local_size}" -gt 0 ]; then
        return 0
    else
        log "Size verification failed: local=${local_size}, remote=${remote_size}"
        return 1
    fi
}

# Function to transfer a single file with retry logic
transfer_file() {
    local file="$1"
    local filename
    filename=$(basename "${file}")
    local file_size
    file_size=$(get_file_size "${file}")
    
    log "Transferring: ${filename} (${file_size} bytes)"
    
    for attempt in $(seq 1 "${RETRY_ATTEMPTS}"); do
        log "Transfer attempt ${attempt}/${RETRY_ATTEMPTS}: ${filename}"
        
        local start_time
        start_time=$(date +%s)
        
        # Use rsync with bandwidth limiting and progress
        if rsync -avz \
                 --bwlimit="${RATE_LIMIT_KBS}" \
                 --progress \
                 --timeout="${CONNECTION_TIMEOUT}" \
                 -e "ssh -i '${SSH_KEY}' -p ${REMOTE_PORT} -o ConnectTimeout=${CONNECTION_TIMEOUT} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=yes" \
                 "${file}" \
                 "${REMOTE_USER}@${REMOTE_SERVER}:${REMOTE_PATH}/" \
                 >> "${LOG_FILE}" 2>&1; then
            
            local end_time
            end_time=$(date +%s)
            local duration=$((end_time - start_time))
            local transfer_rate
            
            if [ "${duration}" -gt 0 ]; then
                transfer_rate=$(( (file_size / 1024) / duration ))
                log "Transfer successful: ${filename} in ${duration}s (${transfer_rate} KB/s)"
            else
                log "Transfer successful: ${filename} (very fast)"
            fi
            
            # Verify transfer if enabled
            if ! verify_file_transfer "${file}"; then
                log "Transfer verification failed for ${filename}, retrying..."
                continue
            fi
            
            # Delete local file if configured
            if [ "${DELETE_AFTER_TRANSFER}" = "true" ]; then
                if rm -f "${file}"; then
                    log "Deleted local file: ${filename}"
                else
                    log "WARNING: Failed to delete local file: ${filename}"
                fi
            fi
            
            return 0
        else
            log "Transfer failed (attempt ${attempt}/${RETRY_ATTEMPTS}): ${filename}"
            if [ "${attempt}" -lt "${RETRY_ATTEMPTS}" ]; then
                local wait_time=$((attempt * 30))
                log "Waiting ${wait_time} seconds before retry..."
                sleep "${wait_time}"
            fi
        fi
    done
    
    log "ERROR: All transfer attempts failed for ${filename}"
    return 1
}

# Main transfer loop
log "Starting bulk video transfer..."
TRANSFERRED_COUNT=0
FAILED_COUNT=0
TOTAL_SIZE=0
TRANSFER_START_TIME=$(date +%s)

# Process all video files
while IFS= read -r -d '' file; do
    if [ -f "${file}" ]; then
        local file_size
        file_size=$(get_file_size "${file}")
        TOTAL_SIZE=$((TOTAL_SIZE + file_size))
        
        if transfer_file "${file}"; then
            ((TRANSFERRED_COUNT++))
        else
            ((FAILED_COUNT++))
        fi
    fi
done < <(find "${RECORDINGS_DIR}" -name "rec-*.{{ camguard.recording.format }}" -type f -print0 2>/dev/null)

# Calculate transfer summary
TRANSFER_END_TIME=$(date +%s)
TOTAL_DURATION=$((TRANSFER_END_TIME - TRANSFER_START_TIME))
TOTAL_SIZE_MB=$((TOTAL_SIZE / 1024 / 1024))

if [ "${TOTAL_DURATION}" -gt 0 ]; then
    AVERAGE_RATE_MBPS=$(( (TOTAL_SIZE * 8 / 1024 / 1024) / TOTAL_DURATION ))
else
    AVERAGE_RATE_MBPS=0
fi

# Generate transfer summary
log "Transfer Summary:"
log "  Total files processed: ${TOTAL_FILES}"
log "  Successfully transferred: ${TRANSFERRED_COUNT}"
log "  Failed transfers: ${FAILED_COUNT}"
log "  Total data transferred: ${TOTAL_SIZE_MB} MB"
log "  Total time: ${TOTAL_DURATION} seconds"
log "  Average transfer rate: ${AVERAGE_RATE_MBPS} Mbps"
log "  Configured rate limit: ${RATE_LIMIT_MBPS} Mbps"

if [ "${FAILED_COUNT}" -gt 0 ]; then
    log "WARNING: ${FAILED_COUNT} files failed to transfer completely"
    cleanup_and_exit 1
else
    log "All files transferred successfully"
    cleanup_and_exit 0
fi