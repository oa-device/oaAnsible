#!/bin/bash
# CamGuard Video Recording Service
# Generated by Ansible for {{ inventory_hostname }}

set -euo pipefail

# Configuration
RECORDINGS_DIR="{{ camguard.storage.recordings_dir }}"
LOGS_DIR="{{ camguard.storage.logs_dir }}"
LOG_FILE="${LOGS_DIR}/camguard.log"
PID_FILE="${LOGS_DIR}/camguard.pid"

# Video settings
RESOLUTION="{{ camguard.recording.resolution }}"
FRAMERATE="{{ camguard.recording.framerate }}"
BITRATE="{{ camguard.recording.bitrate }}"
CHUNK_DURATION="{{ camguard.recording.chunk_duration }}"
CAMERA_DEVICE="{{ camguard.camera.device_id }}"

{% if camguard.streaming.enabled | default(true) %}
# Streaming settings
RTSP_SERVER="{{ camguard.streaming.server_host }}"
RTSP_PORT="{{ camguard.streaming.rtsp_port }}"
STREAM_PATH="{{ camguard.streaming.stream_path }}"
RTSP_URL="rtsp://${RTSP_SERVER}:${RTSP_PORT}/${STREAM_PATH}"
{% endif %}

# Hardware acceleration settings for macOS
HWACCEL_DECODE="-hwaccel videotoolbox"
HWACCEL_ENCODE="-c:v h264_videotoolbox"

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$$] $*" | tee -a "${LOG_FILE}"
}

# Cleanup function
cleanup() {
    log "Received termination signal, cleaning up..."
    if [[ -n "${FFMPEG_PID:-}" ]] && kill -0 "${FFMPEG_PID}" 2>/dev/null; then
        log "Terminating ffmpeg process ${FFMPEG_PID}"
        kill "${FFMPEG_PID}" 2>/dev/null || true
        wait "${FFMPEG_PID}" 2>/dev/null || true
    fi
    rm -f "${PID_FILE}"
    log "CamGuard service stopped"
    exit 0
}

# Set up signal handlers
trap cleanup SIGTERM SIGINT SIGQUIT

# Create directories if they don't exist
mkdir -p "${RECORDINGS_DIR}" "${LOGS_DIR}"

# Store our PID
echo $$ > "${PID_FILE}"

log "Starting CamGuard video recording service"
log "Configuration:"
log "  Resolution: ${RESOLUTION}@${FRAMERATE}fps"
log "  Recording bitrate: ${BITRATE}"
log "  Chunk duration: ${CHUNK_DURATION}s"
log "  Camera device: ${CAMERA_DEVICE}"
log "  Recordings directory: ${RECORDINGS_DIR}"
{% if camguard.streaming.enabled | default(true) %}
log "  Live streaming: ${RTSP_URL}"
{% endif %}

# Check if ffmpeg is available
if ! command -v ffmpeg >/dev/null 2>&1; then
    log "ERROR: ffmpeg not found in PATH"
    exit 1
fi

{% if camguard.streaming.enabled | default(true) %}
# Check if MediaMTX is running
log "Checking MediaMTX streaming server..."
if ! curl -s "http://${RTSP_SERVER}:9997" >/dev/null 2>&1; then
    log "WARNING: MediaMTX server not responding. Live streaming may not work."
    log "Ensure MediaMTX service is running: launchctl list com.orangead.mediamtx"
fi
{% endif %}

# Check camera access
log "Testing camera access..."
if ! ffmpeg -f avfoundation -list_devices true -i "" 2>&1 | grep -q "AVFoundation video devices"; then
    log "WARNING: Unable to list camera devices. Camera may not be accessible."
fi

# Weekend recording check function
is_weekend_recording_time() {
    local current_day=$(date "+%u")  # 1=Monday, 7=Sunday
    local current_hour=$(date "+%H")
    
    # Recording schedule: Friday 12:00 through Monday 12:00
    # Friday (5): start at 12:00 (12 PM / noon)
    # Saturday (6) and Sunday (7): record all day
    # Monday (1): record until 12:00 (12 PM / noon)
    
    case $current_day in
        5)  # Friday
            [[ $current_hour -ge {{ camguard.schedule.friday_start_hour | default(12) }} ]]
            ;;
        6|7)  # Saturday or Sunday
            true  # Record all day
            ;;
        1)  # Monday  
            [[ $current_hour -lt {{ camguard.schedule.monday_end_hour | default(12) }} ]]
            ;;
        *)  # Tuesday, Wednesday, Thursday
            false  # No recording
            ;;
    esac
}

# Main recording loop
while true; do
    # Check if we should be recording based on weekend schedule
    if ! is_weekend_recording_time; then
        current_day_name=$(date "+%A")
        current_time=$(date "+%H:%M")
        log "Outside weekend recording window (${current_day_name} ${current_time}). Sleeping for 30 minutes..."
        sleep 1800  # Sleep for 30 minutes before checking again
        continue
    fi
    
    # Generate timestamp for current recording chunk
    TIMESTAMP=$(date "+%Y%m%d-%H%M%S")
    RECORDING_FILE="${RECORDINGS_DIR}/rec-${TIMESTAMP}.{{ camguard.recording.format }}"
    
    log "Starting new recording chunk: $(basename "${RECORDING_FILE}")"
    
    # Build ffmpeg command with hardware acceleration and optimized settings (using direct ffmpeg binary)
    FFMPEG_BIN="/opt/homebrew/bin/ffmpeg"
    
    FFMPEG_CMD=(
        "${FFMPEG_BIN}"
        ${HWACCEL_DECODE}  # Hardware decode acceleration
        -f avfoundation    # macOS camera input format
        -framerate "${FRAMERATE}"  # Explicit framerate to avoid NTSC conversion
        -i "${CAMERA_DEVICE}"  # Camera device
        -t "${CHUNK_DURATION}"  # Chunk duration
        
        # Video encoding settings (shared for both outputs)
        ${HWACCEL_ENCODE}  # Hardware encode acceleration
        -b:v "${BITRATE}"
        -r "${FRAMERATE}"
        -s "${RESOLUTION}"
{% if camguard.recording.preset is defined %}
        -preset "{{ camguard.recording.preset }}"  # Compression efficiency
{% else %}
        -preset medium  # Default to medium for better compression
{% endif %}
{% if camguard.recording.crf is defined %}
        -crf {{ camguard.recording.crf }}  # Constant Rate Factor for quality/size balance
{% endif %}
{% if camguard.recording.profile is defined %}
        -profile:v "{{ camguard.recording.profile }}"  # H.264 profile
{% endif %}
{% if camguard.recording.level is defined %}
        -level:v "{{ camguard.recording.level }}"  # H.264 level
{% endif %}
        -movflags +faststart  # Optimize for web playback
        
{% if camguard.streaming.enabled | default(true) %}
        # Tee muxer for dual output: recording file + RTSP stream
        -f tee
        -map 0:v  # Map video stream
        "[f=mp4]${RECORDING_FILE}|[f=rtsp]${RTSP_URL}"
{% else %}
        # Single output: recording file only
        "${RECORDING_FILE}"
{% endif %}
    )
    
    log "Executing: ${FFMPEG_CMD[*]}"
    
    # Start ffmpeg in background and capture its PID
    "${FFMPEG_CMD[@]}" 2>> "${LOG_FILE}" &
    FFMPEG_PID=$!
    
    # Wait for the chunk to complete or process to fail
    if wait "${FFMPEG_PID}"; then
        log "Recording chunk completed successfully: $(basename "${RECORDING_FILE}")"
        # Verify the file was created and has reasonable size
        if [[ -f "${RECORDING_FILE}" ]]; then
            FILE_SIZE=$(stat -f%z "${RECORDING_FILE}" 2>/dev/null || echo 0)
            if [[ "${FILE_SIZE}" -gt 1048576 ]]; then  # > 1MB
                log "Recording verified: $(basename "${RECORDING_FILE}") (${FILE_SIZE} bytes)"
            else
                log "WARNING: Recording file seems too small: $(basename "${RECORDING_FILE}") (${FILE_SIZE} bytes)"
            fi
        else
            log "ERROR: Recording file not created: $(basename "${RECORDING_FILE}")"
        fi
    else
        log "ERROR: ffmpeg process failed for chunk: $(basename "${RECORDING_FILE}")"
        log "Waiting 10 seconds before retry..."
        sleep 10
    fi
    
    unset FFMPEG_PID
    
    # Brief pause between chunks
    sleep 1
done